# hosts/hypervisor/default.nix
# Physical hypervisor host configuration
# Manages: MicroVM storage, Tailscale, MicroVM lifecycle
{ config, pkgs, self, ... }:
{
  imports = [
    # Generated by: nixos-generate-config
    # Contains: boot.loader, fileSystems, hardware config
    ./hardware-configuration.nix

    # Network bridges, NAT, firewall
    ./network.nix

    # GitOps deployment automation
    ./comin.nix
  ];

  # Nix settings
  nix.settings.experimental-features = [
    "nix-command"
    "flakes"
  ];

  nix.settings.trusted-users = [
    "root"
    "@wheel"
  ];

  nix.gc = {
    automatic = true;
    dates = "weekly";
    options = "--delete-older-than 7d";
  };

  # Allow unfree packages
  nixpkgs.config.allowUnfree = true;

  networking.hostName = "hypervisor";

  # Tailscale for remote access and subnet routing
  services.tailscale.enable = true;

  # Environment configuration
  environment.variables = {
    EDITOR = "nvim";
  };

  environment.shellAliases = {
    "ccode" = "npx -y @anthropic-ai/claude-code --dangerously-skip-permissions";
  };

  # Program configurations
  programs.neovim.enable = true;
  programs.neovim.defaultEditor = true;
  programs.direnv.enable = true;

  # Basic system tools
  environment.systemPackages = with pkgs; [
    vim
    git
    htop
    tmux
    curl
    wget
    nodejs
    jq
    awscli2  # For fetching AWS Secrets Manager secrets
  ];

  # SSH with key-only auth
  services.openssh = {
    enable = true;
    settings = {
      PermitRootLogin = "prohibit-password";
      PasswordAuthentication = false;
      KbdInteractiveAuthentication = false;
    };
  };

  # Sudo configuration
  security.sudo.wheelNeedsPassword = false;
  security.sudo.extraConfig = ''
    robertwendt ALL=(ALL) NOPASSWD:ALL
  '';

  # Create an admin user (customize as needed)
  users.users.admin = {
    isNormalUser = true;
    extraGroups = [ "wheel" "networkmanager" ];
    # Add your SSH public key here:
    # openssh.authorizedKeys.keys = [ "ssh-ed25519 AAAA..." ];
  };

  # Root user: allow SSH with robertwendt's key
  users.users.root.openssh.authorizedKeys.keys = [
    "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIHJNEMM9i3WgPeA5dDmU7KMWTCcwLLi4EWfX8CKXuK7s robertwendt@Roberts-Laptop.local"
  ];

  # Additional user: robertwendt
  users.users.robertwendt = {
    isNormalUser = true;
    extraGroups = [ "wheel" ];
    openssh.authorizedKeys.keys = [
      "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIHJNEMM9i3WgPeA5dDmU7KMWTCcwLLi4EWfX8CKXuK7s robertwendt@Roberts-Laptop.local"
    ];
  };

  # Declare MicroVMs
  microvm.vms = {
    vm1 = {
      flake = self;
      updateFlake = "root/simple-microvm-infra";
    };
    vm2 = {
      flake = self;
      updateFlake = "root/simple-microvm-infra";
    };
    vm3 = {
      flake = self;
      updateFlake = "root/simple-microvm-infra";
    };
    vm4 = {
      flake = self;
      updateFlake = "root/simple-microvm-infra";
    };
    vm5 = {
      flake = self;
      updateFlake = "root/simple-microvm-infra";
    };
  };

  # Auto-start all VMs on boot
  microvm.autostart = [ "vm1" "vm2" "vm3" "vm4" "vm5" ];

  # Create MicroVM storage directory on root filesystem
  # This is simpler than ZFS but uses the root volume for storage
  systemd.tmpfiles.rules = [
    "d /var/lib/microvms 0755 root root -"
    "d /var/lib/microvms/vm1 0755 root root -"
    "d /var/lib/microvms/vm1/secrets 0700 root root -"  # Secrets directory for VM1
    "d /var/lib/microvms/vm2 0755 root root -"
    "d /var/lib/microvms/vm3 0755 root root -"
    "d /var/lib/microvms/vm4 0755 root root -"
    "d /var/lib/microvms/vm5 0755 root root -"
  ];

  # Fetch AWS Secrets Manager secrets on hypervisor (has IAM role)
  # and make them available to VMs via virtiofs shares
  systemd.services.fetch-vm1-secrets = {
    description = "Fetch secrets from AWS Secrets Manager for VM1";
    wantedBy = [ "multi-user.target" ];
    before = [ "microvm@vm1.service" ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
    };
    script = ''
      set -euo pipefail

      SECRET_NAME="bmnixos"
      REGION="us-west-2"
      ENV_FILE="/var/lib/microvms/vm1/secrets/sandbox.env"

      echo "Fetching secret from AWS Secrets Manager..."
      SECRET_JSON=$(${pkgs.awscli2}/bin/aws secretsmanager get-secret-value \
        --secret-id "$SECRET_NAME" \
        --region "$REGION" \
        --query SecretString \
        --output text)

      # Parse JSON and write to env file
      echo "Writing environment variables to $ENV_FILE..."
      echo "$SECRET_JSON" | ${pkgs.jq}/bin/jq -r 'to_entries | .[] | "\(.key)=\(.value)"' > "$ENV_FILE"

      # Secure the file
      chmod 600 "$ENV_FILE"

      echo "Successfully fetched and wrote secrets to $ENV_FILE"
    '';
  };

  # Systemd services to add TAP interfaces to bridges when VMs start
  systemd.services."microvm-bridge-vm1" = {
    description = "Add vm-vm1 TAP interface to br-vm1 bridge";
    after = [ "microvm-tap-interfaces@vm1.service" ];
    bindsTo = [ "microvm@vm1.service" ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStart = "${pkgs.iproute2}/bin/ip link set vm-vm1 master br-vm1";
      ExecStop = "${pkgs.iproute2}/bin/ip link set vm-vm1 nomaster";
    };
    wantedBy = [ "microvm@vm1.service" ];
  };

  systemd.services."microvm-bridge-vm2" = {
    description = "Add vm-vm2 TAP interface to br-vm2 bridge";
    after = [ "microvm-tap-interfaces@vm2.service" ];
    bindsTo = [ "microvm@vm2.service" ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStart = "${pkgs.iproute2}/bin/ip link set vm-vm2 master br-vm2";
      ExecStop = "${pkgs.iproute2}/bin/ip link set vm-vm2 nomaster";
    };
    wantedBy = [ "microvm@vm2.service" ];
  };

  systemd.services."microvm-bridge-vm3" = {
    description = "Add vm-vm3 TAP interface to br-vm3 bridge";
    after = [ "microvm-tap-interfaces@vm3.service" ];
    bindsTo = [ "microvm@vm3.service" ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStart = "${pkgs.iproute2}/bin/ip link set vm-vm3 master br-vm3";
      ExecStop = "${pkgs.iproute2}/bin/ip link set vm-vm3 nomaster";
    };
    wantedBy = [ "microvm@vm3.service" ];
  };

  systemd.services."microvm-bridge-vm4" = {
    description = "Add vm-vm4 TAP interface to br-vm4 bridge";
    after = [ "microvm-tap-interfaces@vm4.service" ];
    bindsTo = [ "microvm@vm4.service" ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStart = "${pkgs.iproute2}/bin/ip link set vm-vm4 master br-vm4";
      ExecStop = "${pkgs.iproute2}/bin/ip link set vm-vm4 nomaster";
    };
    wantedBy = [ "microvm@vm4.service" ];
  };

  systemd.services."microvm-bridge-vm5" = {
    description = "Add vm-vm5 TAP interface to br-vm5 bridge";
    after = [ "microvm-tap-interfaces@vm5.service" ];
    bindsTo = [ "microvm@vm5.service" ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStart = "${pkgs.iproute2}/bin/ip link set vm-vm5 master br-vm5";
      ExecStop = "${pkgs.iproute2}/bin/ip link set vm-vm5 nomaster";
    };
    wantedBy = [ "microvm@vm5.service" ];
  };

  # Fix microvm service to use correct working directory
  systemd.services."microvm@".serviceConfig.WorkingDirectory = "/var/lib/microvms/%i";

  # NixOS version (don't change after initial install)
  system.stateVersion = "24.05";
}
