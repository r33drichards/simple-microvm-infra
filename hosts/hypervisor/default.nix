# hosts/hypervisor/default.nix
# Physical hypervisor host configuration
# Manages: MicroVM storage, Tailscale, MicroVM lifecycle
#
# Portable State Architecture:
# - Slots are fixed network identities (slot1 = 10.1.0.2, etc.)
# - States are portable ZFS datasets in /var/lib/microvms/states/
# - Use vm-state CLI to manage states
{ config, pkgs, self, ... }:
{
  imports = [
    # Generated by: nixos-generate-config
    # Contains: boot.loader, fileSystems, hardware config
    ./hardware-configuration.nix

    # Network bridges, NAT, firewall
    ./network.nix

    # GitOps deployment automation
    ./comin.nix

    # VM auto-restart module (manual control)
    ../../modules/microvm-auto-restart.nix

    # Redis services
    ./redis.nix

    # Incus for VMs with full KVM support
    ./incus.nix

    # DNS allowlist filtering for MicroVMs
    ./dns-allowlist.nix

    # EBS volume management with ZFS
    ../../modules/ebs-volume
  ];

  # Nix settings
  nix.settings.experimental-features = [
    "nix-command"
    "flakes"
  ];

  nix.settings.trusted-users = [
    "root"
    "@wheel"
  ];

  nix.gc = {
    automatic = true;
    dates = "weekly";
    options = "--delete-older-than 7d";
  };

  # Allow unfree packages
  nixpkgs.config.allowUnfree = true;

  networking.hostName = "hypervisor";

  # EBS volume with ZFS for microvm storage (enables ZFS snapshots)
  # States are stored as child datasets for portability:
  #   microvms/states/slot1, microvms/states/slot2, etc.
  # Use vm-state CLI to manage states and assignments
  services.ebsVolumes = {
    enable = true;
    volumes."microvm-storage" = {
      mountPoint = "/var/lib/microvms";
      sizeGiB = 100;
      poolName = "microvms";
      dataset = "storage";
      volumeType = "gp3";
      device = "/dev/sdf";
      # Per-slot default state datasets
      childDatasets = [ "states" ];
      # Ownership for microvm service
      mountOwner = "microvm";
      mountGroup = "kvm";
      mountDirMode = "0755";
    };
  };

  # Tailscale for remote access and subnet routing
  services.tailscale.enable = true;

  # Environment configuration
  environment.variables = {
    EDITOR = "nvim";
  };

  environment.shellAliases = {
    "ccode" = "npx -y @anthropic-ai/claude-code --dangerously-skip-permissions";
  };

  # Program configurations
  programs.neovim.enable = true;
  programs.neovim.defaultEditor = true;
  programs.direnv.enable = true;

  # Basic system tools
  environment.systemPackages = with pkgs; [
    vim
    git
    htop
    tmux
    curl
    wget
    nodejs
    jq
    awscli2

    # vm-state CLI for managing portable VM states
    (pkgs.writeShellScriptBin "vm-state" (builtins.readFile ../../scripts/vm-state.sh))

    # Custom script to reset all slot storage volumes
    (pkgs.writeShellScriptBin "reset-storage" ''
      set -euo pipefail

      echo "=== Resetting all slot storage volumes ==="
      echo ""

      # Stop all slots
      echo "Stopping all slots..."
      for slot in slot1 slot2 slot3 slot4 slot5; do
        echo "  - Stopping $slot..."
        systemctl stop microvm@$slot || true
      done
      echo "All slots stopped."
      echo ""

      # Delete all persistent volumes
      echo "Deleting persistent volumes..."
      for slot in slot1 slot2 slot3 slot4 slot5; do
        volume="/var/lib/microvms/states/$slot/data.img"
        if [ -f "$volume" ]; then
          echo "  - Deleting $volume..."
          rm "$volume"
        else
          echo "  - $volume does not exist (skipping)"
        fi
      done
      echo "All volumes deleted."
      echo ""

      # Start all slots (they will recreate volumes on first boot)
      echo "Starting all slots..."
      for slot in slot1 slot2 slot3 slot4 slot5; do
        echo "  - Starting $slot..."
        systemctl start microvm@$slot
      done
      echo "All slots started."
      echo ""

      echo "=== Storage reset complete ==="
      echo "New volumes will be created automatically on slot boot."
    '')
  ];

  # SSH with key-only auth
  services.openssh = {
    enable = true;
    settings = {
      PermitRootLogin = "prohibit-password";
      PasswordAuthentication = false;
      KbdInteractiveAuthentication = false;
    };
  };

  # Sudo configuration
  security.sudo.wheelNeedsPassword = false;
  security.sudo.extraConfig = ''
    robertwendt ALL=(ALL) NOPASSWD:ALL
  '';

  # Create an admin user (customize as needed)
  users.users.admin = {
    isNormalUser = true;
    extraGroups = [ "wheel" "networkmanager" ];
    # Add your SSH public key here:
    # openssh.authorizedKeys.keys = [ "ssh-ed25519 AAAA..." ];
  };

  # Root user: allow SSH with robertwendt's key
  users.users.root.openssh.authorizedKeys.keys = [
    "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIHJNEMM9i3WgPeA5dDmU7KMWTCcwLLi4EWfX8CKXuK7s robertwendt@Roberts-Laptop.local"
  ];

  # Additional user: robertwendt
  users.users.robertwendt = {
    isNormalUser = true;
    extraGroups = [ "wheel" ];
    openssh.authorizedKeys.keys = [
      "ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIHJNEMM9i3WgPeA5dDmU7KMWTCcwLLi4EWfX8CKXuK7s robertwendt@Roberts-Laptop.local"
    ];
  };

  # Declare MicroVM slots
  microvm.vms = {
    slot1 = {
      flake = self;
      updateFlake = "root/simple-microvm-infra";
    };
    slot2 = {
      flake = self;
      updateFlake = "root/simple-microvm-infra";
    };
    slot3 = {
      flake = self;
      updateFlake = "root/simple-microvm-infra";
    };
    slot4 = {
      flake = self;
      updateFlake = "root/simple-microvm-infra";
    };
    slot5 = {
      flake = self;
      updateFlake = "root/simple-microvm-infra";
    };
  };

  # Auto-start all slots on boot
  microvm.autostart = [ "slot1" "slot2" "slot3" "slot4" "slot5" ];

  # Keep slot runners as GC roots to prevent garbage collection
  # This ensures the microvm runners aren't deleted during nix-collect-garbage
  # Access via self.nixosConfigurations since slots are defined at flake level
  system.extraDependencies = [
    self.nixosConfigurations.slot1.config.microvm.declaredRunner
    self.nixosConfigurations.slot2.config.microvm.declaredRunner
    self.nixosConfigurations.slot3.config.microvm.declaredRunner
    self.nixosConfigurations.slot4.config.microvm.declaredRunner
    self.nixosConfigurations.slot5.config.microvm.declaredRunner
  ];

  # Create MicroVM storage directories
  # Slots directory holds slot-specific runtime state
  # States directory holds portable persistent data
  systemd.tmpfiles.rules = [
    "d /var/lib/microvms 0755 microvm kvm -"
    "d /var/lib/microvms/states 0755 microvm kvm -"
    # Create default state directories for each slot
    "d /var/lib/microvms/states/slot1 0755 microvm kvm -"
    "d /var/lib/microvms/states/slot2 0755 microvm kvm -"
    "d /var/lib/microvms/states/slot3 0755 microvm kvm -"
    "d /var/lib/microvms/states/slot4 0755 microvm kvm -"
    "d /var/lib/microvms/states/slot5 0755 microvm kvm -"
    # Slot runtime directories (for symlinks, sockets, etc.)
    "d /var/lib/microvms/slot1 0755 microvm kvm -"
    "d /var/lib/microvms/slot2 0755 microvm kvm -"
    "d /var/lib/microvms/slot3 0755 microvm kvm -"
    "d /var/lib/microvms/slot4 0755 microvm kvm -"
    "d /var/lib/microvms/slot5 0755 microvm kvm -"
  ];

  # Helper script to wait for TAP interface and attach to bridge
  environment.etc."microvm-bridge-attach.sh".source = pkgs.writeScript "microvm-bridge-attach" ''
    #!${pkgs.bash}/bin/bash
    TAP=$1
    BRIDGE=$2

    # Wait up to 30 seconds for the TAP interface to appear
    for i in $(seq 1 30); do
      if ${pkgs.iproute2}/bin/ip link show "$TAP" &>/dev/null; then
        ${pkgs.iproute2}/bin/ip link set "$TAP" master "$BRIDGE"
        exit 0
      fi
      sleep 1
    done

    echo "Timeout waiting for $TAP interface"
    exit 1
  '';

  # Systemd services to add TAP interfaces to bridges when slots start
  # These services wait for the microvm to start and the TAP interface to be created by QEMU
  systemd.services."microvm-bridge-slot1" = {
    description = "Add vm-slot1 TAP interface to br-slot1 bridge";
    after = [ "microvm@slot1.service" ];
    bindsTo = [ "microvm@slot1.service" ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStart = "${pkgs.bash}/bin/bash /etc/microvm-bridge-attach.sh vm-slot1 br-slot1";
      ExecStop = "-${pkgs.iproute2}/bin/ip link set vm-slot1 nomaster";
    };
    wantedBy = [ "microvm@slot1.service" ];
  };

  systemd.services."microvm-bridge-slot2" = {
    description = "Add vm-slot2 TAP interface to br-slot2 bridge";
    after = [ "microvm@slot2.service" ];
    bindsTo = [ "microvm@slot2.service" ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStart = "${pkgs.bash}/bin/bash /etc/microvm-bridge-attach.sh vm-slot2 br-slot2";
      ExecStop = "-${pkgs.iproute2}/bin/ip link set vm-slot2 nomaster";
    };
    wantedBy = [ "microvm@slot2.service" ];
  };

  systemd.services."microvm-bridge-slot3" = {
    description = "Add vm-slot3 TAP interface to br-slot3 bridge";
    after = [ "microvm@slot3.service" ];
    bindsTo = [ "microvm@slot3.service" ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStart = "${pkgs.bash}/bin/bash /etc/microvm-bridge-attach.sh vm-slot3 br-slot3";
      ExecStop = "-${pkgs.iproute2}/bin/ip link set vm-slot3 nomaster";
    };
    wantedBy = [ "microvm@slot3.service" ];
  };

  systemd.services."microvm-bridge-slot4" = {
    description = "Add vm-slot4 TAP interface to br-slot4 bridge";
    after = [ "microvm@slot4.service" ];
    bindsTo = [ "microvm@slot4.service" ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStart = "${pkgs.bash}/bin/bash /etc/microvm-bridge-attach.sh vm-slot4 br-slot4";
      ExecStop = "-${pkgs.iproute2}/bin/ip link set vm-slot4 nomaster";
    };
    wantedBy = [ "microvm@slot4.service" ];
  };

  systemd.services."microvm-bridge-slot5" = {
    description = "Add vm-slot5 TAP interface to br-slot5 bridge";
    after = [ "microvm@slot5.service" ];
    bindsTo = [ "microvm@slot5.service" ];
    serviceConfig = {
      Type = "oneshot";
      RemainAfterExit = true;
      ExecStart = "${pkgs.bash}/bin/bash /etc/microvm-bridge-attach.sh vm-slot5 br-slot5";
      ExecStop = "-${pkgs.iproute2}/bin/ip link set vm-slot5 nomaster";
    };
    wantedBy = [ "microvm@slot5.service" ];
  };

  # Fix microvm service to use correct working directory
  systemd.services."microvm@".serviceConfig.WorkingDirectory = "/var/lib/microvms/%i";

  # NixOS version (don't change after initial install)
  system.stateVersion = "24.05";
}
